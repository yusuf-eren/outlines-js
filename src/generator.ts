/**
 * Encapsulate a model and an output type into a reusable object.
 */

import { SteerableModel } from './models';
import { Model, AsyncModel } from './models/base';
import {
  CFGLogitsProcessor,
  GuideLogitsProcessor,
  OutlinesLogitsProcessor,
  RegexLogitsProcessor,
} from './processors';
import { RegexGuide } from './processors/guide';
import { CFG, FSM } from './types';
import {
  typescriptTypesToTerms as pythonTypesToTerms,
  toRegex,
} from './types/dsl';

/**
 * Represents a generator for which we control constrained generation.
 *
 * The generator is responsible for building and storing the logits processor
 * (which can be quite expensive to build), and then passing it to the model
 * when the generator is called.
 *
 * The argument defining constrained generation can be of 2 types associated
 * to different methods to create an instance of the generator:
 * - `outputType` (through `constructor`): an output type as defined in the
 *   `outlines.types` module
 * - `processor` (through `fromProcessor`): an already built logits processor
 *    as defined in the `outlines.processors` module
 *
 * The 2 parameters are mutually exclusive.
 */
export class SteerableGenerator {
  public model: SteerableModel;
  public logitsProcessor: OutlinesLogitsProcessor | null;

  constructor(model: SteerableModel, outputType?: any) {
    /**
     * Parameters
     * ----------
     * model
     *     An instance of an Outlines model.
     * outputType
     *     The output type expressed as a Python type
     */
    this.model = model;

    if (outputType == null) {
      this.logitsProcessor = null;
    } else {
      const term = pythonTypesToTerms(outputType);

      if (term instanceof CFG) {
        const cfgString = term.definition;
        this.logitsProcessor = new CFGLogitsProcessor(
          cfgString,
          this.createTokenizerAdapter(this.model.tokenizer),
          this.model.tensorLibraryName
        );
      } else if (term instanceof FSM) {
        // For now, convert FSM to regex string as a workaround
        // In a full implementation, we'd need proper FSM to guide conversion
        const regexString = toRegex(term);
        const guide = RegexGuide.fromRegex(
          regexString,
          this.createTokenizerAdapter(this.model.tokenizer)
        );
        this.logitsProcessor = new GuideLogitsProcessor(
          this.createTokenizerAdapter(this.model.tokenizer),
          guide,
          this.model.tensorLibraryName
        );
      } else {
        const regexString = toRegex(term);
        this.logitsProcessor = new RegexLogitsProcessor(
          regexString,
          this.createTokenizerAdapter(this.model.tokenizer),
          this.model.tensorLibraryName
        );
      }
    }
  }

  /**
   * Create a tokenizer adapter that matches the Tokenizer interface expected by processors
   */
  private createTokenizerAdapter(transformerTokenizer: any): any {
    return {
      eosToken: transformerTokenizer.eos_token,
      eosTokenId: transformerTokenizer.eos_token_id,
      padTokenId: transformerTokenizer.pad_token_id,
      vocabulary: transformerTokenizer.vocabulary,
      specialTokens: Array.from(transformerTokenizer.special_tokens || []),
      encode: (text: string) => transformerTokenizer.encode(text),
      decode: (tokenIds: number[]) => transformerTokenizer.decode(tokenIds),
      convertTokenToString: (token: string) => {
        // Use the existing method if available, otherwise return token as-is
        if (transformerTokenizer.convert_tokens_to_string) {
          return transformerTokenizer.convert_tokens_to_string([token]);
        }
        return token;
      },
    };
  }

  /**
   * Create a generator from a logits processor.
   *
   * Parameters
   * ----------
   * model
   *     An instance of an Outlines model.
   * processor
   *     An instance of an OutlinesLogitsProcessor.
   */
  static fromProcessor(
    model: SteerableModel,
    processor: OutlinesLogitsProcessor
  ): SteerableGenerator {
    if (!(processor instanceof OutlinesLogitsProcessor)) {
      throw new TypeError(
        'The processor argument must be an instance of OutlinesLogitsProcessor'
      );
    }

    const instance = Object.create(SteerableGenerator.prototype);
    instance.model = model;
    instance.logitsProcessor = processor;

    return instance;
  }

  /**
   * Generate a response from the model.
   *
   * Parameters
   * ----------
   * prompt
   *     The prompt to use to generate a response.
   * inferenceKwargs
   *     Additional keyword arguments to pass to the model.
   *
   * Returns
   * -------
   * any
   *     The response generated by the model.
   */
  call(prompt: any, inferenceKwargs: Record<string, any> = {}): any {
    return this.model.generate(
      prompt,
      this.logitsProcessor || undefined,
      inferenceKwargs
    );
  }

  /**
   * Generate a stream of responses from the model.
   *
   * Parameters
   * ----------
   * prompt
   *     The prompt to use to generate a response.
   * inferenceKwargs
   *     Additional keyword arguments to pass to the model.
   *
   * Returns
   * -------
   * Iterator<any>
   *     The response generated by the model.
   */
  stream(
    prompt: any,
    inferenceKwargs: Record<string, any> = {}
  ): Iterator<any> {
    return this.model.generateStream(
      prompt,
      this.logitsProcessor || undefined,
      inferenceKwargs
    );
  }
}

/**
 * Generator interface for future BlackBox implementations
 */
export interface BlackBoxGenerator {
  model: any;
  outputType: any;
  call(prompt: any, inferenceKwargs?: Record<string, any>): any;
  stream(prompt: any, inferenceKwargs?: Record<string, any>): Iterator<any>;
}

/**
 * AsyncGenerator interface for future async BlackBox implementations
 */
export interface AsyncBlackBoxGenerator {
  model: any;
  outputType: any;
  call(prompt: any, inferenceKwargs?: Record<string, any>): Promise<any>;
  stream(
    prompt: any,
    inferenceKwargs?: Record<string, any>
  ): AsyncIterator<any>;
}

/**
 * Union type for all generator types
 */
export type GeneratorType =
  | SteerableGenerator
  | BlackBoxGenerator
  | AsyncBlackBoxGenerator;

/**
 * Create a generator for the given model and output parameters.
 *
 * The 2 parameters outputType and processor are mutually exclusive. The
 * parameter processor is only supported for SteerableModel instances
 * (typically local models) and is intended to be only used by advanced users.
 *
 * Parameters
 * ----------
 * model
 *     An instance of an Outlines model.
 * outputType
 *     The output type expressed as a Python type or a type defined in the
 *     outlines.types.dsl module.
 * processor
 *     An instance of an OutlinesLogitsProcessor.
 *
 * Returns
 * -------
 * GeneratorType
 *     A generator instance.
 */
export function Generator(
  model: Model | AsyncModel,
  outputType?: any,
  options: {
    processor?: OutlinesLogitsProcessor;
  } = {}
): GeneratorType {
  const { processor } = options;

  const providedOutputParams = [outputType, processor].filter(
    (param) => param != null
  ).length;

  if (providedOutputParams > 1) {
    throw new Error('At most one of outputType or processor can be provided');
  }

  // For now, we only support SteerableModel (Transformers)
  // In the future, BlackBox and AsyncBlackBox models can be added here
  if (isSteerableModel(model)) {
    if (processor != null) {
      return SteerableGenerator.fromProcessor(model, processor);
    } else {
      return new SteerableGenerator(model, outputType);
    }
  } else {
    throw new Error(
      'Currently only SteerableModel is supported. ' +
        'BlackBoxModel and AsyncBlackBoxModel will be added in future versions.'
    );
  }
}

/**
 * Type guard to check if a model is a SteerableModel
 */
function isSteerableModel(model: Model | AsyncModel): model is SteerableModel {
  // For now, we assume all models are steerable since that's what we have
  // This can be refined when more model types are added
  return (
    'tokenizer' in model && 'tensorLibraryName' in model && 'generate' in model
  );
}

// Export default
export default {
  SteerableGenerator,
  Generator,
};
