// src/models/base.ts

// We import the Generator function, not a class constructor.
// The Generator function returns an instance of SteerableGenerator, BlackBoxGenerator, or AsyncBlackBoxGenerator.
import {
  Generator,
  BlackBoxGenerator,
  AsyncBlackBoxGenerator,
  SteerableGenerator,
} from '../generator'; // Assuming Generator function is in src/generator.ts

/**
 * Base class for all model type adapters.
 *
 * A type adapter instance must be given as a value to the `typeAdapter`
 * attribute when instantiating a model.
 * The type adapter is responsible for formatting the input and output types
 * passed to the model to match the specific format expected by the
 * associated model.
 */
export interface ModelTypeAdapter {
  /**
   * Format the user input to the expected format of the model.
   *
   * For API-based models, it typically means creating the `messages`
   * argument passed to the client. For local models, it can mean casting
   * the input from str to list for instance.
   * This method is also used to validate that the input type provided by
   * the user is supported by the model.
   *
   * @param modelInput The input provided by the user.
   * @returns The formatted input to be passed to the model.
   */
  formatInput(modelInput: any): any;

  /**
   * Format the output type to the expected format of the model.
   *
   * For API-based models, this typically means creating a `response_format`
   * argument. For local models, it means formatting the logits processor to
   * create the object type expected by the model.
   *
   * @param outputType The output type provided by the user (optional).
   * @returns The formatted output type to be passed to the model.
   */
  formatOutputType(outputType?: any): any;
}

/**
 * Base class for all synchronous models.
 *
 * This class defines a shared `call` method that can be used to call the
 * model directly.
 * All models inheriting from this class must define a `typeAdapter`
 * attribute of type `ModelTypeAdapter`. The methods of the `typeAdapter`
 * attribute are used in the `generate` method to format the input and output
 * types received by the model.
 * Additionally, local models must define a `tensorLibraryName` attribute.
 */
export abstract class Model {
  abstract typeAdapter: ModelTypeAdapter;
  tensorLibraryName?: string;

  /**
   * Call the model.
   *
   * Users can call the model directly, in which case we will create a
   * generator instance with the output type provided and call it.
   * Thus, those commands are equivalent:
   * ```typescript
   * const generator = Generator(model, Foo); // No 'new' here
   * generator.generate("prompt");
   * ```
   * and
   * ```typescript
   * model.call("prompt", Foo);
   * ```
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns The response generated by the model.
   */
  public call(
    modelInput: any,
    outputType?: any,
    inferenceKwargs: Record<string, any> = {}
  ): any {
    const generator = Generator(this, outputType);
    return generator.call(modelInput, inferenceKwargs);
  }

  /**
   * Stream a response from the model.
   *
   * Users can use the `stream` method from the model directly, in which
   * case we will create a generator instance with the output type provided
   * and then invoke its `stream` method.
   * Thus, those commands are equivalent:
   * ```typescript
   * const generator = Generator(model, Foo); // No 'new' here
   * for (const chunk of generator.stream("prompt")) { // Note: generator.stream is Iterable
   *     console.log(chunk);
   * }
   * ```
   * and
   * ```typescript
   * for (const chunk of model.stream("prompt", Foo)) {
   *     console.log(chunk);
   * }
   * ```
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns An `Iterable` of responses from the model.
   */
  public *stream(
    modelInput: any,
    outputType?: any,
    inferenceKwargs: Record<string, any> = {}
  ): Iterable<any> {
    const generator = Generator(this, outputType);
    return generator.stream(modelInput, inferenceKwargs);
  }

  /**
   * Generate a response from the model.
   *
   * The `outputType` argument contains a logits processor for local models
   * while it contains a type (Json, Enum...) for the API-based models.
   * This method is not intended to be used directly by end users.
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns The response generated by the model.
   */
  public abstract generate(
    modelInput: any,
    outputType?: any,
    inferenceKwargs?: Record<string, any>
  ): any;

  /**
   * Generate a stream of responses from the model.
   *
   * The `outputType` argument contains a logits processor for local models
   * while it contains a type (Json, Enum...) for the API-based models.
   * This method is not intended to be used directly by end users.
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns A stream of responses from the model.
   */
  public abstract generateStream(
    modelInput: any,
    outputType?: any,
    inferenceKwargs?: Record<string, any>
  ): Iterable<any>;
}

/**
 * Base class for all asynchronous models.
 *
 * This class defines a shared `call` method that can be used to call the
 * model directly.
 * All models inheriting from this this class must define a `typeAdapter`
 * attribute of type `ModelTypeAdapter`. The methods of the `typeAdapter`
 * attribute are used in the `generate` method to format the input and output
 * types received by the model.
 * Additionally, local models must define a `tensorLibraryName` attribute.
 */
export abstract class AsyncModel {
  abstract typeAdapter: ModelTypeAdapter;
  abstract tensorLibraryName: string;

  /**
   * Call the model.
   *
   * Users can call the model directly, in which case we will create a
   * generator instance with the output type provided and call it.
   * Thus, those commands are equivalent:
   * ```typescript
   * const generator = Generator(model, Foo); // No 'new' here
   * await generator.generate("prompt");
   * ```
   * and
   * ```typescript
   * await model.call("prompt", Foo);
   * ```
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns The response generated by the model.
   */
  public async call(
    modelInput: any,
    outputType?: any,
    inferenceKwargs: Record<string, any> = {}
  ): Promise<any> {
    const generator = Generator(this, outputType);
    return generator.call(modelInput, inferenceKwargs);
  }

  /**
   * Stream a response from the model.
   *
   * Users can use the `stream` method from the model directly, in which
   * case we will create a generator instance with the output type provided
   * and then invoke its `stream` method.
   * Thus, those commands are equivalent:
   * ```typescript
   * const generator = Generator(model, Foo); // No 'new' here
   * async for await (const chunk of generator.stream("prompt")) {
   *     console.log(chunk);
   * }
   * ```
   * and
   * ```typescript
   * async for await (const chunk of model.stream("prompt", Foo)) {
   *     console.log(chunk);
   * }
   * ```
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns An `AsyncIterable` of responses from the model.
   */
  public async *stream(
    modelInput: any,
    outputType?: any,
    inferenceKwargs: Record<string, any> = {}
  ): AsyncIterable<any> {
    const generator = Generator(this, outputType);
    return generator.stream(modelInput, inferenceKwargs);
  }

  /**
   * Generate a response from the model.
   *
   * The `outputType` argument contains a logits processor for local models
   * while it contains a type (Json, Enum...) for the API-based models.
   * This method is not intended to be used directly by end users.
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns A promise that resolves to the response generated by the model.
   */
  public abstract generate(
    modelInput: any,
    outputType?: any,
    inferenceKwargs?: Record<string, any>
  ): Promise<any>; // Corrected: removed 'async', added Promise<any>

  /**
   * Generate a stream of responses from the model.
   *
   * The `outputType` argument contains a logits processor for local models
   * while it contains a type (Json, Enum...) for the API-based models.
   * This method is not intended to be used directly by end users.
   *
   * @param modelInput The input provided by the user.
   * @param outputType The output type provided by the user (optional).
   * @param inferenceKwargs Additional keyword arguments to pass to the model.
   * @returns An `AsyncIterable` of responses from the model.
   */
  public abstract generateStream(
    modelInput: any,
    outputType?: any,
    inferenceKwargs?: Record<string, any>
  ): AsyncIterable<any>;
}

// TODO: Could be used in other classes to python-like functionality.
/**
 * This class is converted from javascript to typescript,
 * which is provided by `@huggingface/transformers` library.
 * A base class for creating callable objects.
 * See [here](https://stackoverflow.com/q/76073890) for more information.
 */
export const Callable = class {
  /**
   * Creates a new instance of the Callable class.
   */
  constructor() {
    /**
     * Creates a closure that delegates to a private method '_call' with the given arguments.
     */
    const closure = function (...args: any[]): any {
      return (closure as any)._call(...args);
    };
    return Object.setPrototypeOf(closure, new.target.prototype);
  }

  /**
   * This method should be implemented in subclasses to provide the
   * functionality of the callable object.
   */
  _call(...args: any[]): any {
    throw new Error('Must implement _call method in subclass');
  }
} as any;

